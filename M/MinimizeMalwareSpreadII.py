'''
-Hard-
*Union Find*

(This problem is the same as Minimize Malware Spread, with the differences bolded.)

In a network of nodes, each node i is directly connected to another node j if and 
only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are 
directly connected and at least one of those two nodes is infected by malware, 
both nodes will be infected by malware.  This spread of malware will continue 
until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the 
entire network, after the spread of malware stops.

We will remove one node from the initial list, completely removing it and any 
connections from this node to any other node.  Return the node that if removed, 
would minimize M(initial).  If multiple nodes could be removed to minimize 
M(initial), return such a node with the smallest index.

 

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1
Example 3:

Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1
 

Note:

1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length


'''
import collections
import itertools  
class Solution(object):
    def minMalwareSpreadBFS(self, graph, initial):
        '''
        see detailed explanation here
        https://leetcode.com/problems/minimize-malware-spread-ii/discuss/184129/python-solution-with-my-thinking-process-(with-extra-Chinese-explanation) 
        '''
        n = len(graph)
        d = collections.defaultdict(list)
        for init in initial:
            vis = set(initial)
            Q = collections.deque([init])
            while Q:
                infect = Q.popleft()
                for node in range(len(graph[infect])):
                    if graph[infect][node] == 0: continue
                    if node in vis: continue
                    vis.add(node)
                    d[node].append(init)
                    Q.append(node)
        # count the most frequent node
        res = [0] * n
        for key in d:
            if len(d[key]) == 1: # 
                res[d[key][0]] += 1
        if max(res) == 0: return min(initial)
        return res.index(max(res))

    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        n = len(graph)       
        def find(roots, i):        
            while roots[i] != i:            
               roots[i] = roots[roots[i]] 
               i = roots[i]
            return i
        def union(i,j):
            x, y = find(roots, j), find(roots, i)
            if x != y: roots[x] = y 
        min_infected = n+1        
        res = 0
        nodes = set([i for i in range(n)])            
        for k in sorted(initial):                        
            roots = [j for j in range(n)]
            for i in range(n):
                for j in range(n):  
                    if i != k and j != k and graph[i][j] == 1:
                        union(i, j)
            infected = 0
            A = set(initial)
            A.remove(k)
            B = nodes-A
            for j in B:
                for l in A:
                    if find(roots, j) == find(roots, l):
                        infected += 1
                        break
            infected += len(initial)-1 
            if min_infected > infected:
                min_infected = infected
                res = k 
        return res
    
    def minMalwareSpreadUnionFind(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        # 91%
        N = len(graph)
        clean = list(set(range(N)) - set(initial))
        parents, size = list(range(N)), [1] * N
        
        def find(a):
            while parents[a] != a:
                parents[a] = parents[parents[a]]
                a = parents[a]
            return a
        
        def union(a, b):
            ra, rb = find(a), find(b)
            if ra != rb:
                if size[ra] > size[rb]:
                    parents[rb] = ra
                    size[ra] += size[rb]
                else:
                    parents[ra] = rb
                    size[rb] += size[ra]
                    
        for u, v in itertools.combinations(clean, 2):
            if graph[u][v]: union(u, v)
                
        infect_node, infected_by, max, res = collections.defaultdict(set), collections.Counter(), -1, min(initial)
        
        for u in initial:
            for v in clean:
                if graph[u][v]:
                    infect_node[u].add(find(v))
            for i in infect_node[u]:
                infected_by[i] += 1
                
        for i, nodes in infect_node.items():
            count = 0
            for node in nodes:
                if infected_by[node] == 1: count += size[node]
            if count > max or count == max and i < res:
                max, res = count, i
        return res


if __name__ == "__main__":
    print(Solution().minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]))
    print(Solution().minMalwareSpread([[1,1,0],[1,1,1],[0,1,1]], [0,1]))
    print(Solution().minMalwareSpread([[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], 
                                     [0,1]))
    